var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _reactDom = require("react-dom");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _styles = require("@material-ui/styles");
var _utils = require("@material-ui/utils");
var _ownerDocument = require("../utils/ownerDocument");
var _ownerDocumentDefault = parcelHelpers.interopDefault(_ownerDocument);
var _portal = require("../Portal");
var _portalDefault = parcelHelpers.interopDefault(_portal);
var _createChainedFunction = require("../utils/createChainedFunction");
var _createChainedFunctionDefault = parcelHelpers.interopDefault(_createChainedFunction);
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
var _useEventCallback = require("../utils/useEventCallback");
var _useEventCallbackDefault = parcelHelpers.interopDefault(_useEventCallback);
var _zIndex = require("../styles/zIndex");
var _zIndexDefault = parcelHelpers.interopDefault(_zIndex);
var _modalManager = require("./ModalManager");
var _modalManagerDefault = parcelHelpers.interopDefault(_modalManager);
var _unstableTrapFocus = require("../Unstable_TrapFocus");
var _unstableTrapFocusDefault = parcelHelpers.interopDefault(_unstableTrapFocus);
var _simpleBackdrop = require("./SimpleBackdrop");
var _simpleBackdropDefault = parcelHelpers.interopDefault(_simpleBackdrop);
function getContainer(container) {
    container = typeof container === 'function' ? container() : container;
    return _reactDom.findDOMNode(container);
}
function getHasTransition(props) {
    return props.children ? props.children.props.hasOwnProperty('in') : false;
} // A modal manager used to track and manage the state of open Modals.
// Modals don't open on the server so this won't conflict with concurrent requests.
var defaultManager = new _modalManagerDefault.default();
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            position: 'fixed',
            zIndex: theme.zIndex.modal,
            right: 0,
            bottom: 0,
            top: 0,
            left: 0
        },
        /* Styles applied to the root element if the `Modal` has exited. */ hidden: {
            visibility: 'hidden'
        }
    };
};
/**
 * Modal is a lower-level construct that is leveraged by the following components:
 *
 * - [Dialog](/api/dialog/)
 * - [Drawer](/api/drawer/)
 * - [Menu](/api/menu/)
 * - [Popover](/api/popover/)
 *
 * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component
 * rather than directly using Modal.
 *
 * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
 */ var Modal = /*#__PURE__*/ _react.forwardRef(function Modal1(inProps, ref) {
    var theme = _styles.useTheme();
    var props = _styles.getThemeProps({
        name: 'MuiModal',
        props: _extendsDefault.default({
        }, inProps),
        theme: theme
    });
    var _props$BackdropCompon = props.BackdropComponent, BackdropComponent = _props$BackdropCompon === void 0 ? _simpleBackdropDefault.default : _props$BackdropCompon, BackdropProps = props.BackdropProps, children = props.children, _props$closeAfterTran = props.closeAfterTransition, closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran, container = props.container, _props$disableAutoFoc = props.disableAutoFocus, disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$disableBackdro = props.disableBackdropClick, disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro, _props$disableEnforce = props.disableEnforceFocus, disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce, _props$disableEscapeK = props.disableEscapeKeyDown, disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK, _props$disablePortal = props.disablePortal, disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal, _props$disableRestore = props.disableRestoreFocus, disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore, _props$disableScrollL = props.disableScrollLock, disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL, _props$hideBackdrop = props.hideBackdrop, hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop, _props$keepMounted = props.keepMounted, keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted, _props$manager = props.manager, manager = _props$manager === void 0 ? defaultManager : _props$manager, onBackdropClick = props.onBackdropClick, onClose = props.onClose, onEscapeKeyDown = props.onEscapeKeyDown, onRendered = props.onRendered, open = props.open, other = _objectWithoutPropertiesDefault.default(props, [
        "BackdropComponent",
        "BackdropProps",
        "children",
        "closeAfterTransition",
        "container",
        "disableAutoFocus",
        "disableBackdropClick",
        "disableEnforceFocus",
        "disableEscapeKeyDown",
        "disablePortal",
        "disableRestoreFocus",
        "disableScrollLock",
        "hideBackdrop",
        "keepMounted",
        "manager",
        "onBackdropClick",
        "onClose",
        "onEscapeKeyDown",
        "onRendered",
        "open"
    ]);
    var _React$useState = _react.useState(true), exited = _React$useState[0], setExited = _React$useState[1];
    var modal = _react.useRef({
    });
    var mountNodeRef = _react.useRef(null);
    var modalRef = _react.useRef(null);
    var handleRef = _useForkRefDefault.default(modalRef, ref);
    var hasTransition = getHasTransition(props);
    var getDoc = function getDoc1() {
        return _ownerDocumentDefault.default(mountNodeRef.current);
    };
    var getModal = function getModal1() {
        modal.current.modalRef = modalRef.current;
        modal.current.mountNode = mountNodeRef.current;
        return modal.current;
    };
    var handleMounted = function handleMounted1() {
        manager.mount(getModal(), {
            disableScrollLock: disableScrollLock
        }); // Fix a bug on Chrome where the scroll isn't initially 0.
        modalRef.current.scrollTop = 0;
    };
    var handleOpen = _useEventCallbackDefault.default(function() {
        var resolvedContainer = getContainer(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer); // The element was already mounted.
        if (modalRef.current) handleMounted();
    });
    var isTopModal = _react.useCallback(function() {
        return manager.isTopModal(getModal());
    }, [
        manager
    ]);
    var handlePortalRef = _useEventCallbackDefault.default(function(node) {
        mountNodeRef.current = node;
        if (!node) return;
        if (onRendered) onRendered();
        if (open && isTopModal()) handleMounted();
        else _modalManager.ariaHidden(modalRef.current, true);
    });
    var handleClose = _react.useCallback(function() {
        manager.remove(getModal());
    }, [
        manager
    ]);
    _react.useEffect(function() {
        return function() {
            handleClose();
        };
    }, [
        handleClose
    ]);
    _react.useEffect(function() {
        if (open) handleOpen();
        else if (!hasTransition || !closeAfterTransition) handleClose();
    }, [
        open,
        handleClose,
        hasTransition,
        closeAfterTransition,
        handleOpen
    ]);
    if (!keepMounted && !open && (!hasTransition || exited)) return null;
    var handleEnter = function handleEnter1() {
        setExited(false);
    };
    var handleExited = function handleExited1() {
        setExited(true);
        if (closeAfterTransition) handleClose();
    };
    var handleBackdropClick = function handleBackdropClick1(event) {
        if (event.target !== event.currentTarget) return;
        if (onBackdropClick) onBackdropClick(event);
        if (!disableBackdropClick && onClose) onClose(event, 'backdropClick');
    };
    var handleKeyDown = function handleKeyDown1(event) {
        // The handler doesn't take event.defaultPrevented into account:
        //
        // event.preventDefault() is meant to stop default behaviours like
        // clicking a checkbox to check it, hitting a button to submit a form,
        // and hitting left arrow to move the cursor in a text input etc.
        // Only special HTML elements have these default behaviors.
        if (event.key !== 'Escape' || !isTopModal()) return;
        if (onEscapeKeyDown) onEscapeKeyDown(event);
        if (!disableEscapeKeyDown) {
            // Swallow the event, in case someone is listening for the escape key on the body.
            event.stopPropagation();
            if (onClose) onClose(event, 'escapeKeyDown');
        }
    };
    var inlineStyle = styles(theme || {
        zIndex: _zIndexDefault.default
    });
    var childProps = {
    };
    if (children.props.tabIndex === undefined) childProps.tabIndex = children.props.tabIndex || '-1';
     // It's a Transition like component
    if (hasTransition) {
        childProps.onEnter = _createChainedFunctionDefault.default(handleEnter, children.props.onEnter);
        childProps.onExited = _createChainedFunctionDefault.default(handleExited, children.props.onExited);
    }
    return(/*#__PURE__*/ _react.createElement(_portalDefault.default, {
        ref: handlePortalRef,
        container: container,
        disablePortal: disablePortal
    }, /*#__PURE__*/ _react.createElement("div", _extendsDefault.default({
        ref: handleRef,
        onKeyDown: handleKeyDown,
        role: "presentation"
    }, other, {
        style: _extendsDefault.default({
        }, inlineStyle.root, !open && exited ? inlineStyle.hidden : {
        }, other.style)
    }), hideBackdrop ? null : /*#__PURE__*/ _react.createElement(BackdropComponent, _extendsDefault.default({
        open: open,
        onClick: handleBackdropClick
    }, BackdropProps)), /*#__PURE__*/ _react.createElement(_unstableTrapFocusDefault.default, {
        disableEnforceFocus: disableEnforceFocus,
        disableAutoFocus: disableAutoFocus,
        disableRestoreFocus: disableRestoreFocus,
        getDoc: getDoc,
        isEnabled: isTopModal,
        open: open
    }, /*#__PURE__*/ _react.cloneElement(children, childProps)))));
});
Modal.propTypes = {
    /**
   * A backdrop component. This prop enables custom backdrop rendering.
   */ BackdropComponent: _propTypesDefault.default.elementType,
    /**
   * Props applied to the [`Backdrop`](/api/backdrop/) element.
   */ BackdropProps: _propTypesDefault.default.object,
    /**
   * A single child content element.
   */ children: _utils.elementAcceptingRef.isRequired,
    /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   */ closeAfterTransition: _propTypesDefault.default.bool,
    /**
   * A HTML element, component instance, or function that returns either.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */ container: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .oneOfType([_utils.HTMLElementType, _propTypesDefault.default.instanceOf(_react.Component),
        _propTypesDefault.default.func
    ]),
    /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   */ disableAutoFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, clicking the backdrop will not fire `onClose`.
   */ disableBackdropClick: _propTypesDefault.default.bool,
    /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   */ disableEnforceFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, hitting escape will not fire `onClose`.
   */ disableEscapeKeyDown: _propTypesDefault.default.bool,
    /**
   * Disable the portal behavior.
   * The children stay within it's parent DOM hierarchy.
   */ disablePortal: _propTypesDefault.default.bool,
    /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden.
   */ disableRestoreFocus: _propTypesDefault.default.bool,
    /**
   * Disable the scroll lock behavior.
   */ disableScrollLock: _propTypesDefault.default.bool,
    /**
   * If `true`, the backdrop is not rendered.
   */ hideBackdrop: _propTypesDefault.default.bool,
    /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   */ keepMounted: _propTypesDefault.default.bool,
    /**
   * @ignore
   */ manager: _propTypesDefault.default.object,
    /**
   * Callback fired when the backdrop is clicked.
   */ onBackdropClick: _propTypesDefault.default.func,
    /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */ onClose: _propTypesDefault.default.func,
    /**
   * Callback fired when the escape key is pressed,
   * `disableEscapeKeyDown` is false and the modal is in focus.
   */ onEscapeKeyDown: _propTypesDefault.default.func,
    /**
   * Callback fired once the children has been mounted into the `container`.
   * It signals that the `open={true}` prop took effect.
   *
   * This prop will be deprecated and removed in v5, the ref can be used instead.
   */ onRendered: _propTypesDefault.default.func,
    /**
   * If `true`, the modal is open.
   */ open: _propTypesDefault.default.bool.isRequired
};
exports.default = Modal;
